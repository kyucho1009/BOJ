#include <bits/stdc++.h>
using namespace std;

int maze[5][5][5];
int board[4][5][5][5]; // board[회전 수][층][행][열]
int dx[6] = {1, 0, 0, -1, 0, 0};
int dy[6] = {0, 1, 0, 0, -1, 0};
int dz[6] = {0, 0, 1, 0, 0, -1};

int bfs()
{
    int dist[5][5][5] = {
        // 거리를 측정할 3차원 배열
        0,
    };
    /*
    Q. 근데 왜 [0][0][0]을 입구 [4][4][4]를 출구로 고정하나요? [0][0][4]를 입구 [4][4][0]을 출구로 할 수도 있잖아요
    A. 우리는 어짜피 main함수에서 각판을 회전하고 각 판을 쌓는 모든 경우를 확인할것이므로 상관이 없다
    현재 미로의 [0][0][0] -> [4][4][4]의 최단거리를 구하는것이 다른 미로의 [0][0][4] -> [4][4][0]과 같기 떄문이다
    */
    if (maze[0][0][0] == 0 || maze[4][4][4] == 0) //[0][0][0]좌표 또는 [4][4][4]좌표값이 0이면 이동하지 못하는 부분이므로 바로 9999반환하며 함수 종료
        return 9999;
    queue<tuple<int, int, int>> Q;
    dist[0][0][0] = 1;
    Q.push({0, 0, 0});
    while (!Q.empty())
    {
        tuple<int, int, int> cur = Q.front();
        Q.pop();
        for (int dir = 0; dir < 6; dir++)
        {
            int nx = get<0>(cur) + dx[dir];
            int ny = get<1>(cur) + dy[dir];
            int nz = get<2>(cur) + dz[dir];
            if (nx < 0 || nx >= 5 || ny < 0 || ny >= 5 || nz < 0 || nz >= 5)
                continue;
            if (dist[nx][ny][nz] != 0 || maze[nx][ny][nz] == 0)
                continue;
            if (nx == 4 && ny == 4 && nz == 4)
                return dist[get<0>(cur)][get<1>(cur)][get<2>(cur)];
            dist[nx][ny][nz] = dist[get<0>(cur)][get<1>(cur)][get<2>(cur)] + 1;
            Q.push({nx, ny, nz});
        }
    }
    return 9999;
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    for (int i = 0; i < 5; i++)
    {
        for (int j = 0; j < 5; j++)
            for (int k = 0; k < 5; k++)
                cin >> board[0][i][j][k]; // 처음 보드 입력

        for (int j = 0; j < 5; j++)
            for (int k = 0; k < 5; k++)
                board[1][i][j][k] = board[0][i][k][4 - j]; // 1번 회전한 보드 생성

        for (int j = 0; j < 5; j++)
            for (int k = 0; k < 5; k++)
                board[2][i][j][k] = board[1][i][k][4 - j]; // 2번 회전한 보드 생성

        for (int j = 0; j < 5; j++)
            for (int k = 0; k < 5; k++)
                board[3][i][j][k] = board[2][i][k][4 - j]; // 3번 회전한 보드 생성
    }
    int ans = 9999;                 // 초기값 설정
    int order[5] = {0, 1, 2, 3, 4}; // 보드 쌓는 순서
    do
    {
        for (int tmp = 0; tmp < 1024; tmp++)
        {
            int brute = tmp;
            for (int i = 0; i < 5; i++)
            {
                int dir = brute % 4; // 0부터 1023까지의 수를 4진법으로 변환하는 과정
                brute /= 4;
                for (int j = 0; j < 5; j++)
                    for (int k = 0; k < 5; k++)
                        maze[i][j][k] = board[dir][order[i]][j][k]; // next_permutation을 통해 얻은 순서대로 dir만큼 회전한 판을 쌓아서 maze를 만든다
            }
            ans = min(ans, bfs()); // 위에서 만들어진 maze로 BFS 사용, 반환된 최단거리 min함수를 이용해 비교하기
        }
    } while (next_permutation(order, order + 5)); // {0, 1, 2, 3, 4}의 모든 조합만큼 반복
    if (ans == 9999)
        ans = -1;
    cout << ans;
}

/*
1. 판 회전 (4^5 => 1024)
2. 미로 생성
3. 입구, 출구 지정 (20 * 4 => 80)
4. bfs 최단거리 탐색
5. 1 ~ 4 반복
*/

/*
문제를 해결할 방향은 떠올렸지만 구체적인 구현 방법에서 막혔다

해당 문제는 5개의 판을 회전시키고 각 판들을 자유롭게 쌓아 미로를 만들고 한 꼭짓점에서 반대 대각선 방향의 꼭짓점까지의 최단 거리를 구하는 문제이다
(이 문제는 7569번 토마토와 유사한 문제이다)

내가 떠올린 문제의 해결 방향은 BFS 알고리즘을 사용하는것이다
(우리는 두 지점 사이의 최단거리를 구해야 하기에 BFS 알고리즘을 사용해야 한다)

두 지점 사이의 최단거리를 구하는 방법을 알았으니 이제는 각 판을 회전시키고 판들을 자유롭게 쌓는 모든 경우를 세어보자

먼저 각 판을 회전시키면 4가지 상태를 가질 수 있다

판의 개수는 총 5개

각 판들을 쌓는 순서는 총 5! = 120

따라서 모든 경우의 수는 4^5 * 120 = 122880
(부르트포스를 사용해도 문제가 없다는것을 확인 할 수 있다)

그렇다면 이제 자세한 구현 방법을 알아보자

먼저 각 판을 만들어준다
board[4][5][5][5] 이렇게 판을 만들어준 이유는 다음과 같다
board[회전 수][판의 번호][행][열] ex)board[1][2][3][4] -> 2번 판을 1번 90도 회전 시킨 3행 4열의 수를 의미한다

board를 만들어준 후 next_permutation을 이용해 판을 쌓을 순서들의 조합을 구하고
tmp와 brute 변수를 우리가 위에서 구해봤던 각 판들을 회전시켜 얻을 수 있는 조합은 1024로 0부터 1024까지 숫자를 반복하며 4의 나머지와 몫을 계속해서 구해준다
0의 경우 -> dir 변수에 0, 0, 0, 0, 0
1의 경우 -> dir 변수에 1, 0, 0, 0, 0
2의 경우 -> dir 변수에 2, 0, 0, 0, 0
3의 경우 -> dir 변수에 3, 0, 0, 0, 0
4의 경우 -> dir 변수에 0, 1, 0, 0, 0
...
100의 경우 -> dir 변수에 0, 1, 2, 1, 0
위의 예시들처럼 0부터 1024까지의 수가 4진법으로 변환되어 dir 변수에 들어가고 각 판을 몇번 회전시킬지 결정한다

각 판들의 회전하는 모든 경우의 수와 회전한 각판들을 쌓는 모든 경우에서 BFS 알고리즘을 사용하면 최단거리를 알 수 있다
(잘 모르겠으면 코드와 함께 봐라)
*/