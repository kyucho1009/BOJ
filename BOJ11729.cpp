#include <bits/stdc++.h>
using namespace std;

void func(int a, int b, int n)
{
    if (n == 1)
    {
        cout << a << ' ' << b << "\n";
        return;
    }
    func(a, 6 - a - b, n - 1);     // 1 -> 2로 n - 1개의 원판 치우기
    cout << a << ' ' << b << "\n"; // 1 -> 3으로 맨 아래 원판 옮기기
    func(6 - a - b, b, n - 1);     // 2 -> 3으로 n - 1개의 원판 올리기
}

int main(void)
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    int k;
    cin >> k;
    cout << (1 << k) - 1 << "\n";
    func(1, 3, k); // 1 -> 3으로 k개 옮기기
    return 0;
}

/*
- 문제
    1번 봉에서 3번 봉으로 우리는 k개의 원판을 옯겨야 한다.

- 해결방법
    위의 문제를 해결하는 방법은 간단하다. (어렵게 생각 ㄴㄴ, 단순하게 접근하셈)
    1 -> 3으로 k개의 원판을 옮기고 싶다면 아래의 3가지 절차를 따르면 된다

    1. k - 1개의 원판을 1 -> 2로 치운다(그래야지 맨 아래의 원판을 옮길 수 있으니까)
    2. 맨 아래의 원판을 3으로 옮긴다
    3. 1번에서 옮겼던 원판을 2 -> 3으로 올린다(끝.)

    위의 절차와 같이 매우 간단하다.
    그러나 처음에는 아래와 같이 여러가지 의문점이 들 수 있다.
    (저도 너무 어려웠습니다ㅠ 그러나 다른분의 코드를 살펴보고 저의 생각을 단순화 하는 과정으로 이해할 수 있었습니다)
    (재귀의 사고 과정을 너무 어렵지만 구현과정은 무엇보다 단순합니다)
    (귀납적 사고 과정을 장착하고 간단한 코드를 작성하면 컴퓨터가 알아서 잘해결해줍니다)

    Q. 그러면 k -1개의 원판은 어떻게 옮겨요?
    A. 위의 절차를  따라서 k - 2개의 원판을 치우고 맨아래 원판을 옮긴 후 k - 2개의 원판을 올린다.
        (이렇게 반복을 하면 언젠가는 1개의 원판만 치워주면 되는 상황이 옵니다)

    Q. func() 함수를 보면 k - 1개를 치우고 올리는건 알겠어요. 맨 아래의 원판을 옮기는건 왜 없죠?
    A. 우리가 실제 원판을 옮기는 것도 아니고 상상속의 하노이탑을 옮기는 거니까 출력문을 통해 옮겼다고 표현하는 겁니다.
*/