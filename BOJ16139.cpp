#include <bits/stdc++.h>
using namespace std;

int q;
int st;
int en;
char alpha;
int arr[26][200001];
string S;

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> S;
    cin >> q;
    for (int i = 1; i <= S.length(); i++)
    {
        int a;
        a = S[i - 1] - 97;
        for (int j = 0; j < 26; j++)
        {
            if (a == j)
                arr[j][i] = arr[j][i - 1] + 1;
            else
                arr[j][i] = arr[j][i - 1];
        }
    }
    while (q--)
    {
        cin >> alpha >> st >> en;
        cout << arr[alpha - 97][en + 1] - arr[alpha - 97][st] << "\n";
    }
    return 0;
}
/*
- 문제 접근법
알파벳 소문자 개수인 26과 문자열 길이를 바탕으로 2차원 배열을 생성해 알파벳 등장 개수의 누적합을 저장한다
ex) arr[26][문자열길이 + 1] -> 여기서 문자열 길이에 1을 더해주는 이유는 누적합 저장을 위해 배열의 가장 첫 값은 0으로 저장하기 위해서
좀 더 자세히 설명하자면 1열은 문자열의 0번 인덱스까지의 각 알파벳 별 등장횟수의 누적합을 보여주고
2열은 문자열의 1번 인덱스까지의 각 알파벳별 등장횟수의 누적합을 보여준다.

위와 같이 2차원 배열을 만들고 문자열을 탐색하면서 N번 열에 N-1번 인덱스까지의 알파벳 누적합을 저장한다
누적합을 저장하는 2차원 배열을 완성했다면 우리는 l번째 문자부터 r번째 문자까지 특정 알파벳이 몇번 등장하는지 확인해야한다

누적합 배열을 완성했다면 특정 구간에서 알파벳의 등장횟수를 구하는건 간단하다
우리의 목표 구간이 l에서 r까지라면 r번 인덱스 누적합에서 l - 1번 인덱스 누적합을 빼주는것이다
r번 인덱스의 누적합은 0 ~ r까지의 누적합이고 l - 1인덱스의 누적합은 0 ~ l-1이므로 빼준다면 l ~ r의 누적합을 구할 수 있다.
*/